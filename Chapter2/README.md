# 제 2고지

## 11단계. 가변 길이 인수 (순전파 편)
- 함수의 입력과 출력은 2개 이상일 수 있음
- 변수들을 리스트 혹은 튜플에 넣어 처리
- Add 클래스를 사용하기 위해 입력 변수를 리스트에 담거나 튜플을 반환받는 것은 자연스럽지 않음

## 12단계. 가변 길이 인수 (개선 편)
- Add 및 함수 클래스 사용자를 위한 개선
    - 기존: 인수를 리스트에 모아서 받고 결과를 튜플로 반환
    - 개선: 인수와 결과를 직접 주고받음
- 구현자를 위한 개선
    - 리스트를 unpack하여 `self.forward`호출

## 13단계. 가변 길이 인수 (역전파 편)
- x+y=z 의 역전파: 입력이 1개, 출력이 2개 ( $\frac{\delta x}{\delta z}=1$ , $\frac{\delta y}{\delta z}=1$ )
- 가변 인수의 역전파 값을 Variable class 에서 저장할 수 있도록 함

## 14단계. 같은 변수 반복 사용
- 현재의 문제: 같은 변수를 반복해서 사용 시 의도대로 동작하지 않을 수 있음
- e.g. $x+x$ 의 경우 미분값이 전파되면서 덮어쓰기 때문에 1로 계산됨 
- 전달된 미분값을 더해주도록 Variable class 수정
- 변수 재사용 시 누적적으로 더해지는 것을 막기 위해 미분값 초기화 메서드 추가

## 15단계. 복잡한 계산 그래프 (이론 편)
- 다양한 위상의 계산 그래프 역전파 계산하기 
    - e.g 중간에 분기했다가 다시 합류하는 경우
- step14의 Variable class는 funcs리스트의 끝에서 꺼내어 처리함
- 이 경우 두 갈래로 나누어진 함수는 역전파를 두 번 계산하게 됨 
- 이 문제를 해결하기 위해 함수의 우선순위를 설정

## 16단계. 복잡한 계산 그래프 (구현 편)
- Variable class / Function class에 generation 변수 추가
- 순전파 시 모든 변수와 함수에 세대가 설정됨
- 세대를 정렬한 후 pop 메서드로 세대가 큰 함수부터 얻을 수 있음
- Variable class의 backward 메서드에 add_func 함수 정의

## 17단계. 메모리 관리와 순환 참조
- 메모리 관리: 코드를 작성할 때 메모리 누수와 메모리 부족을 조심해야함
- 파이썬(Cpython)의 메모리 관리
    - 1. 참조 카운트: 참조 수를 세는 방식
    - 2. GC(garbage collection): 세대를 기준으로 쓸모없어진 객체를 회수 
### 참조 카운트
    - 구조가 간단하고 속도가 빠름
    - 모든 객체는 참조 카운트가 0인 상태로 생성되고, 다른 객체가 참조할 때마다 1씩 증가
    - 참조가 끊길 때마다 1만큼 감소하다가 0이 되면 파이썬 인터프리터가 회수해감
    - 더 이상 객체가 필요 없어지면 즉시 메모리에서 삭제 
    e.g 대입 연산자를 사용할 때/ 함수에 인수로 전달할 때/컨테이너 타입 객체에 추가할 때 (리스트, 튜플, 클래스 등)
    - 예외의 경우: 순환 참조 (DeZero의 Function <-> output Variable)
        - weakref로 해결 가능 -> 
        <b> step17.py 코드에 반영 </b>
### GC
    - 메모리가 부족해지는 시점에 파이썬 인터프리터에 의해 자동으로 호출
    - 명시적인 호출 가능 
    `gc.collect()` 

## 18단계. 메모리 절약 모드
메모리 사용을 개선할 수 있는 구조 두 가지
### 필요 없는 미분값 삭제
- 지금은 모든 변수가 미분값을 변수에 저장
- 머신러닝에서는 역전파로 구하고 싶은 값은 말단 변수(맨 처음 사용한 변수)뿐인 경우가 대부분임 
- 중간 변수의 미분값 제거 모드 추가
### 역전파가 필요 없는 경우용 모드 제공 - with 문 활용
- contextlib 모듈 사용 : yield 전에 전처리 로직, yield 다음에 후처리 로직 작성
- getattr, setattr 함수에 모드 이름을 넘겨 Config 클래스 속성 설정
- no_grad() 함수를 설정해 순전파만 사용할 경우의 설정값을 넘겨주는 함수 작성

## 19단계. 변수 사용성 개선
- 변수에 이름 붙이기 - Variable class에 인스턴스 변수 name 추가 
- 목표: Variable 인스턴스를 ndarray 인스턴스처럼 보이게 하기
- ndarray의 shape, dimension, size, data type을 나타내는 인스턴스 변수 추가
- len: 첫 번째 차원의 원소 수 반환
    - `__init__`, `__len__` 처럼 특별한 의미를 지닌 메서드는 밑줄 두개로 감싼 이름 사용
- print: 출력하고자 하는 문자열이 variable임을 알려주면서 프린트시키도록 정의

## 20단계. 연산자 오버로드(1)
- +와 * 연산자를 지원하도록 Variable 확장
- Mul class & def 추가
- 매번 mul(), add()를 쓰는 대신 연산자를 사용할 수 있도록 함
- class Variable 위에 mul, add 함수를 정의해주어야함

## 21단계. 연산자 오버로드(2)
- 다른 종류의 인스턴스 간에 연산이 가능하도록 수정
- np.array와 Variable 의 연산 : as_variable 함수 적용
- float 혹은 int와 연산: `def add` function에 as_array 코드 추가
- 입력하는 인수의 순서 바뀔 경우에도 가능하도록 `Variable.__radd__`, `Variable.__rmul__` 에 각 연산함수 대입
- 연산자 우선순위 지정: Variable 인스턴스의 연산 우선 순위를 ndarray 연산보다 높임

## 22단계. 연산자 오버로드(3)
- neg, sub, rsub, truediv, rtruediv, pow 연산자 추가
- neg: 부호 변환 연산자, 단항 연산자이므로 인수도 하나뿐
- sub, rsub: 뺄셈
- truediv, rtruediv: 나눗셈
- pow: 거듭제곱
- 사칙연산 활용가능! 